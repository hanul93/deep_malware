# -*- coding: utf-8 -*-

import tensorflow as tf
import numpy as np
import math
import sys
import os


# export TF_CPP_MIN_LOG_LEVEL=3


def xavier_init(n_inputs, n_outputs, uniform=True):
    if uniform:
        # 6 was used in the paper.
        init_range = math.sqrt(6.0 / (n_inputs + n_outputs))
        return tf.random_uniform_initializer(-init_range, init_range)
    else:
        # 3 gives us approximately the same limits as above since this repicks
        # values greater than 2 standard deviations from the mean.
        stddev = math.sqrt(3.0 / (n_inputs + n_outputs))
        return tf.truncated_normal_initializer(stddev=stddev)


def sigmoid(x):
    return 1 / (1 + math.exp(-x))


dropout_rate = tf.placeholder('float')

W1 = tf.get_variable('W1', shape=[1024, 1024], initializer=xavier_init(1024, 1024, False))
W2 = tf.get_variable('W2', shape=[1024, 1024], initializer=xavier_init(1024, 1024, False))
W3 = tf.get_variable('W3', shape=[1024, 1024], initializer=xavier_init(1024, 1024, False))
W4 = tf.get_variable('W4', shape=[1024, 2], initializer=xavier_init(1024, 2, False))

B1 = tf.Variable(tf.zeros([1024]))
B2 = tf.Variable(tf.zeros([1024]))
B3 = tf.Variable(tf.zeros([1024]))
B4 = tf.Variable(tf.zeros([2]))

# 악성코드 검사 모델
N_X = tf.placeholder(tf.float32, [1, 1024])

N__L1 = tf.nn.relu(tf.add(tf.matmul(N_X, W1), B1))
N_L1 = tf.nn.dropout(N__L1, dropout_rate)
N__L2 = tf.nn.relu(tf.add(tf.matmul(N_L1, W2), B2))
N_L2 = tf.nn.dropout(N__L2, dropout_rate)
N__L3 = tf.nn.relu(tf.add(tf.matmul(N_L2, W3), B3))
N_L3 = tf.nn.dropout(N__L3, dropout_rate)

hypothesis = tf.add(tf.matmul(N_L3, W4), B4)


class K2AI:
    def __init__(self):
        init = tf.global_variables_initializer()
        sess = tf.Session()
        sess.run(init)

        saver = tf.train.Saver()
        saver.restore(sess, './data/k2.pd')

        self.sess = sess

    def scan(self, data):
        t_x = self.__covert_data(data)
        if t_x is None:
            return 0, -1

        r = self.sess.run(hypothesis, feed_dict={N_X: np.array([t_x]), dropout_rate: 1.0})

        # result
        result = list(r[0])
        max_val = max(result)
        score = int(sigmoid(max_val) * 100)

        # print score

        if score >= 80:
            return result.index(max_val), score  # Malware ID

        return 0, score

        # print result
        # print max(result)
        # print sigmoid(r[0][0]), sigmoid(r[0][1])

    def __del__(self):
        self.sess.close()

    def __covert_data(self, data):
        if len(data) != 1024:
            return None

        ret_data = map(float, map(ord, data))
        return np.array(ret_data)


def load_bin(fname, y):
    ret_x = []
    ret_y = []

    buf = open(fname, 'rb').read()
    for i in range(len(buf) / 1024):
        data = map(float, map(ord, buf[i * 1024:(i + 1) * 1024]))
        ret_x.append(data)

        if y == 0:
            ret_y.append([1.0, 0.0])
        elif y == 1:
            ret_y.append([0.0, 1.0])

    return ret_x, ret_y


if __name__ == '__main__':
    idx = 2
    buf = open('1.bin', 'rb').read()[idx*1024:(idx+1)*1024]

    k2 = K2AI()
    m_id, m_score = k2.scan(buf)
    print m_id, m_score
