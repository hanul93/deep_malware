# -*- coding:utf-8 -*-

import os
import sys
import math
import struct
import mmap
import pe as pefile
import crc16


def getEntropy(data):
    """Calculate the entropy of a chunk of data."""

    if not data:
        return 0

    entropy = 0
    for x in range(256):
        p_x = float(data.count(chr(x)))/len(data)
        if p_x > 0:
          entropy += - p_x*math.log(p_x, 2)

    return entropy

    
def text_entropy(data):
    n_data = len(data)
    
    if n_data < 1024:
        data += '\x00' * (1024 - n_data)
    else:
        data += '\x00' * (n_data % 256)        

    mat_data = set()
    off = 0

    count = ((len(data) - 1024) / 256) + 1
    
    for i in range(count):
        t = data[off:off+1024]
        n = int(getEntropy(t) / 0.5)
        if n >= 16:
            n = 15
        for c in list(set(t)):
            mat_data.add((ord(c) / 2, n))
        off += 256
        
    m = [0] * 256
    for x, y in list(mat_data):
        seg, off = (x / 8), (x % 8)
        c = m[(y * 16) + seg]
        c |= (1 << off)
        m[(y * 16) + seg] = c
        
    ret = ''.join(map(chr, m))
        
    return ret


def data_2gram(data):
    charset = 'abcdefghijklmnopqrstuvwxyz0123456789()_-+=:,.'
    t_data = ''

    for c in data:
        if c in charset:
            t_data += c

    m = ['0'] * 2048
    for i in range(len(t_data) - 1):
        x, y = charset.index(t_data[i]), charset.index(t_data[i+1])
        m[(y * 45) + x] = '1'

    m = ''.join(m)

    t_data = ''
    for i in range(2048/8):
        t_data += chr(int(m[i*8:(i+1)*8], 2))

    return t_data


def import_api(pe_format):
    api_hash = set()

    data = ''

    if 'Import_API' in pe_format:
        imp_api = pe_format['Import_API']

        for dll in imp_api.keys():
            for api in dll:
                api_name = ('%s:%s' % (dll, api)).lower()
                api_hash.add(struct.pack('<H', crc16.CRC16().calculate(api_name)))

        t = list(api_hash)
        data = ''.join(t)

    if len(data) < 256:
        data += '\x00' * (256 - len(data))

    return data[:256]


def pe_feature_sub(mm, fname):
    feature = ''

    try:
        # .text 섹션의 Entropy 구하기
        pe = pefile.PE(mm, False, fname)
        pe_format = pe.parse()
        if not pe_format:
            return None

        pe_off = pe_format['PE_Position']  # pe.DOS_HEADER.e_lfanew
        ep = pe_format['EntryPoint']  # pe.OPTIONAL_HEADER.AddressOfEntryPoint

        text_off = 0
        text_size = 0

        for sec in pe_format['Sections']:  # pe.sections:
            rva = sec['RVA']  # sec.VirtualAddress
            vsize = sec['VirtualSize']  # sec.Misc_VirtualSize
            if rva <= ep <= rva + vsize:
                text_off = sec['PointerRawData']  # sec.PointerToRawData
                text_size = sec['SizeRawData']  # sec.SizeOfRawData
                break

        feature += text_entropy(mm[text_off:text_off + text_size])

        # PE 헤더 정보
        feature += mm[pe_off + 6:pe_off + 6 + 256]

        # DATA 섹션 2-gram 표현하기
        data_off = 0
        data_size = 0

        for sec in pe_format['Sections']:  # pe.sections:
            if sec['Characteristics'] & 0x40000040 == 0x40000040:  # if DATA and Read
                data_off = sec['PointerRawData']  # sec.PointerToRawData
                data_size = sec['SizeRawData']  # sec.SizeOfRawData
                break

        feature += data_2gram(mm[data_off:data_off + data_size])

        # Import API 해시 추가하기
        feature += import_api(pe_format)

        return feature
    except:
        import traceback
        print '[-]', fname
        print traceback.format_exc()
        return None


def pe_feature(fname):
    ret = None

    try:
        fp = open(fname, 'rb')
        mm = mmap.mmap(fp.fileno(), 0, access=mmap.ACCESS_READ)

        if mm[:2] == 'MZ':
            ret = pe_feature_sub(mm, fname)

        mm.close()
        fp.close()
    except IOError:
        pass

    return ret

if __name__ == '__main__':
    path_name = sys.argv[1]

    flist = os.listdir(path_name)
    for fname in flist:
        data = pe_feature(path_name + os.sep + fname)
        if data:
            open(path_name+'.bin', 'ab').write(data)
            print fname
